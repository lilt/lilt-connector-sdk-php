<?php
/**
 * JobsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  LiltConnectorSDK
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Lilt Connector Plugin API
 *
 * This document describes the Plugin API for Lilt's Connector platform. The Plugin API is intented to be used by developers who wish to build integrations into their desired systems. The purpose of this API is to enable content transfer and status monitoring for localization projects.  - Read more about the concepts and workflows in the   [user guide](/docs/api/v1.0). - Test the API interactively via [Swagger UI](/api/v1.0/ui).
 *
 * The version of the OpenAPI document: 1.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.1-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace LiltConnectorSDK\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use LiltConnectorSDK\ApiException;
use LiltConnectorSDK\Configuration;
use LiltConnectorSDK\HeaderSelector;
use LiltConnectorSDK\ObjectSerializer;

/**
 * JobsApi Class Doc Comment
 *
 * @category Class
 * @package  LiltConnectorSDK
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class JobsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'servicesApiJobsAddFile' => [
            'application/octet-stream',
        ],
        'servicesApiJobsCreateJob' => [
            'application/json',
        ],
        'servicesApiJobsDeleteJobById' => [
            'application/json',
        ],
        'servicesApiJobsGetJobById' => [
            'application/json',
        ],
        'servicesApiJobsGetJobs' => [
            'application/json',
        ],
        'servicesApiJobsStartJob' => [
            'application/json',
        ],
        'servicesApiJobsSyncJob' => [
            'application/json',
        ],
        'servicesApiJobsUpdateJob' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation servicesApiJobsAddFile
     *
     * Add a file to a Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $name The file name. (required)
     * @param  string[] $trglang The target language. Many target languages can be added to a source file. To add more than one target language pass in the trglang query parameter multiple times. For example: ?trglang&#x3D;fr-FR&amp;trglang&#x3D;es-ES. (required)
     * @param  string $srclang The source language. (optional, default to 'en-US')
     * @param  \DateTime $due The due date for the file as an ISO-8601 string. (optional)
     * @param  \SplFileObject $body body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsAddFile'] to see the possible values for this operation
     *
     * @throws \LiltConnectorSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function servicesApiJobsAddFile($id, $name, $trglang, $srclang = 'en-US', $due = null, $body = null, string $contentType = self::contentTypes['servicesApiJobsAddFile'][0])
    {
        $this->servicesApiJobsAddFileWithHttpInfo($id, $name, $trglang, $srclang, $due, $body, $contentType);
    }

    /**
     * Operation servicesApiJobsAddFileWithHttpInfo
     *
     * Add a file to a Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $name The file name. (required)
     * @param  string[] $trglang The target language. Many target languages can be added to a source file. To add more than one target language pass in the trglang query parameter multiple times. For example: ?trglang&#x3D;fr-FR&amp;trglang&#x3D;es-ES. (required)
     * @param  string $srclang The source language. (optional, default to 'en-US')
     * @param  \DateTime $due The due date for the file as an ISO-8601 string. (optional)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsAddFile'] to see the possible values for this operation
     *
     * @throws \LiltConnectorSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function servicesApiJobsAddFileWithHttpInfo($id, $name, $trglang, $srclang = 'en-US', $due = null, $body = null, string $contentType = self::contentTypes['servicesApiJobsAddFile'][0])
    {
        $request = $this->servicesApiJobsAddFileRequest($id, $name, $trglang, $srclang, $due, $body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation servicesApiJobsAddFileAsync
     *
     * Add a file to a Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $name The file name. (required)
     * @param  string[] $trglang The target language. Many target languages can be added to a source file. To add more than one target language pass in the trglang query parameter multiple times. For example: ?trglang&#x3D;fr-FR&amp;trglang&#x3D;es-ES. (required)
     * @param  string $srclang The source language. (optional, default to 'en-US')
     * @param  \DateTime $due The due date for the file as an ISO-8601 string. (optional)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsAddFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesApiJobsAddFileAsync($id, $name, $trglang, $srclang = 'en-US', $due = null, $body = null, string $contentType = self::contentTypes['servicesApiJobsAddFile'][0])
    {
        return $this->servicesApiJobsAddFileAsyncWithHttpInfo($id, $name, $trglang, $srclang, $due, $body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation servicesApiJobsAddFileAsyncWithHttpInfo
     *
     * Add a file to a Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $name The file name. (required)
     * @param  string[] $trglang The target language. Many target languages can be added to a source file. To add more than one target language pass in the trglang query parameter multiple times. For example: ?trglang&#x3D;fr-FR&amp;trglang&#x3D;es-ES. (required)
     * @param  string $srclang The source language. (optional, default to 'en-US')
     * @param  \DateTime $due The due date for the file as an ISO-8601 string. (optional)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsAddFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesApiJobsAddFileAsyncWithHttpInfo($id, $name, $trglang, $srclang = 'en-US', $due = null, $body = null, string $contentType = self::contentTypes['servicesApiJobsAddFile'][0])
    {
        $returnType = '';
        $request = $this->servicesApiJobsAddFileRequest($id, $name, $trglang, $srclang, $due, $body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'servicesApiJobsAddFile'
     *
     * @param  int $id The Job ID. (required)
     * @param  string $name The file name. (required)
     * @param  string[] $trglang The target language. Many target languages can be added to a source file. To add more than one target language pass in the trglang query parameter multiple times. For example: ?trglang&#x3D;fr-FR&amp;trglang&#x3D;es-ES. (required)
     * @param  string $srclang The source language. (optional, default to 'en-US')
     * @param  \DateTime $due The due date for the file as an ISO-8601 string. (optional)
     * @param  \SplFileObject $body (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsAddFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function servicesApiJobsAddFileRequest($id, $name, $trglang, $srclang = 'en-US', $due = null, $body = null, string $contentType = self::contentTypes['servicesApiJobsAddFile'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling servicesApiJobsAddFile'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling servicesApiJobsAddFile'
            );
        }

        // verify the required parameter 'trglang' is set
        if ($trglang === null || (is_array($trglang) && count($trglang) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $trglang when calling servicesApiJobsAddFile'
            );
        }





        $resourcePath = '/jobs/{id}/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $srclang,
            'srclang', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $trglang,
            'trglang', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $due,
            'due', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation servicesApiJobsCreateJob
     *
     * Create a Connector Job.
     *
     * @param  \LiltConnectorSDK\Model\NewJobOptions $new_job_options new_job_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsCreateJob'] to see the possible values for this operation
     *
     * @throws \LiltConnectorSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LiltConnectorSDK\Model\JobResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse
     */
    public function servicesApiJobsCreateJob($new_job_options = null, string $contentType = self::contentTypes['servicesApiJobsCreateJob'][0])
    {
        list($response) = $this->servicesApiJobsCreateJobWithHttpInfo($new_job_options, $contentType);
        return $response;
    }

    /**
     * Operation servicesApiJobsCreateJobWithHttpInfo
     *
     * Create a Connector Job.
     *
     * @param  \LiltConnectorSDK\Model\NewJobOptions $new_job_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsCreateJob'] to see the possible values for this operation
     *
     * @throws \LiltConnectorSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LiltConnectorSDK\Model\JobResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function servicesApiJobsCreateJobWithHttpInfo($new_job_options = null, string $contentType = self::contentTypes['servicesApiJobsCreateJob'][0])
    {
        $request = $this->servicesApiJobsCreateJobRequest($new_job_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\LiltConnectorSDK\Model\JobResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\JobResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\JobResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LiltConnectorSDK\Model\JobResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\JobResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation servicesApiJobsCreateJobAsync
     *
     * Create a Connector Job.
     *
     * @param  \LiltConnectorSDK\Model\NewJobOptions $new_job_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsCreateJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesApiJobsCreateJobAsync($new_job_options = null, string $contentType = self::contentTypes['servicesApiJobsCreateJob'][0])
    {
        return $this->servicesApiJobsCreateJobAsyncWithHttpInfo($new_job_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation servicesApiJobsCreateJobAsyncWithHttpInfo
     *
     * Create a Connector Job.
     *
     * @param  \LiltConnectorSDK\Model\NewJobOptions $new_job_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsCreateJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesApiJobsCreateJobAsyncWithHttpInfo($new_job_options = null, string $contentType = self::contentTypes['servicesApiJobsCreateJob'][0])
    {
        $returnType = '\LiltConnectorSDK\Model\JobResponse';
        $request = $this->servicesApiJobsCreateJobRequest($new_job_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'servicesApiJobsCreateJob'
     *
     * @param  \LiltConnectorSDK\Model\NewJobOptions $new_job_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsCreateJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function servicesApiJobsCreateJobRequest($new_job_options = null, string $contentType = self::contentTypes['servicesApiJobsCreateJob'][0])
    {



        $resourcePath = '/jobs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_job_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_job_options));
            } else {
                $httpBody = $new_job_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation servicesApiJobsDeleteJobById
     *
     * Delete a Connector Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsDeleteJobById'] to see the possible values for this operation
     *
     * @throws \LiltConnectorSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function servicesApiJobsDeleteJobById($id, string $contentType = self::contentTypes['servicesApiJobsDeleteJobById'][0])
    {
        $this->servicesApiJobsDeleteJobByIdWithHttpInfo($id, $contentType);
    }

    /**
     * Operation servicesApiJobsDeleteJobByIdWithHttpInfo
     *
     * Delete a Connector Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsDeleteJobById'] to see the possible values for this operation
     *
     * @throws \LiltConnectorSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function servicesApiJobsDeleteJobByIdWithHttpInfo($id, string $contentType = self::contentTypes['servicesApiJobsDeleteJobById'][0])
    {
        $request = $this->servicesApiJobsDeleteJobByIdRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation servicesApiJobsDeleteJobByIdAsync
     *
     * Delete a Connector Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsDeleteJobById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesApiJobsDeleteJobByIdAsync($id, string $contentType = self::contentTypes['servicesApiJobsDeleteJobById'][0])
    {
        return $this->servicesApiJobsDeleteJobByIdAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation servicesApiJobsDeleteJobByIdAsyncWithHttpInfo
     *
     * Delete a Connector Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsDeleteJobById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesApiJobsDeleteJobByIdAsyncWithHttpInfo($id, string $contentType = self::contentTypes['servicesApiJobsDeleteJobById'][0])
    {
        $returnType = '';
        $request = $this->servicesApiJobsDeleteJobByIdRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'servicesApiJobsDeleteJobById'
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsDeleteJobById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function servicesApiJobsDeleteJobByIdRequest($id, string $contentType = self::contentTypes['servicesApiJobsDeleteJobById'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling servicesApiJobsDeleteJobById'
            );
        }


        $resourcePath = '/jobs/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation servicesApiJobsGetJobById
     *
     * Retrieve a Connector Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsGetJobById'] to see the possible values for this operation
     *
     * @throws \LiltConnectorSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LiltConnectorSDK\Model\JobResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse
     */
    public function servicesApiJobsGetJobById($id, string $contentType = self::contentTypes['servicesApiJobsGetJobById'][0])
    {
        list($response) = $this->servicesApiJobsGetJobByIdWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation servicesApiJobsGetJobByIdWithHttpInfo
     *
     * Retrieve a Connector Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsGetJobById'] to see the possible values for this operation
     *
     * @throws \LiltConnectorSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LiltConnectorSDK\Model\JobResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function servicesApiJobsGetJobByIdWithHttpInfo($id, string $contentType = self::contentTypes['servicesApiJobsGetJobById'][0])
    {
        $request = $this->servicesApiJobsGetJobByIdRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LiltConnectorSDK\Model\JobResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\JobResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\JobResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LiltConnectorSDK\Model\JobResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\JobResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation servicesApiJobsGetJobByIdAsync
     *
     * Retrieve a Connector Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsGetJobById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesApiJobsGetJobByIdAsync($id, string $contentType = self::contentTypes['servicesApiJobsGetJobById'][0])
    {
        return $this->servicesApiJobsGetJobByIdAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation servicesApiJobsGetJobByIdAsyncWithHttpInfo
     *
     * Retrieve a Connector Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsGetJobById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesApiJobsGetJobByIdAsyncWithHttpInfo($id, string $contentType = self::contentTypes['servicesApiJobsGetJobById'][0])
    {
        $returnType = '\LiltConnectorSDK\Model\JobResponse';
        $request = $this->servicesApiJobsGetJobByIdRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'servicesApiJobsGetJobById'
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsGetJobById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function servicesApiJobsGetJobByIdRequest($id, string $contentType = self::contentTypes['servicesApiJobsGetJobById'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling servicesApiJobsGetJobById'
            );
        }


        $resourcePath = '/jobs/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation servicesApiJobsGetJobs
     *
     * Retrieve a list of Connector Jobs.
     *
     * @param  int $limit the query limit (optional, default to 25)
     * @param  int $start where to start (optional, default to 0)
     * @param  string $order how to order the returned results (optional, default to 'asc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsGetJobs'] to see the possible values for this operation
     *
     * @throws \LiltConnectorSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LiltConnectorSDK\Model\JobsResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse
     */
    public function servicesApiJobsGetJobs($limit = 25, $start = 0, $order = 'asc', string $contentType = self::contentTypes['servicesApiJobsGetJobs'][0])
    {
        list($response) = $this->servicesApiJobsGetJobsWithHttpInfo($limit, $start, $order, $contentType);
        return $response;
    }

    /**
     * Operation servicesApiJobsGetJobsWithHttpInfo
     *
     * Retrieve a list of Connector Jobs.
     *
     * @param  int $limit the query limit (optional, default to 25)
     * @param  int $start where to start (optional, default to 0)
     * @param  string $order how to order the returned results (optional, default to 'asc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsGetJobs'] to see the possible values for this operation
     *
     * @throws \LiltConnectorSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LiltConnectorSDK\Model\JobsResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function servicesApiJobsGetJobsWithHttpInfo($limit = 25, $start = 0, $order = 'asc', string $contentType = self::contentTypes['servicesApiJobsGetJobs'][0])
    {
        $request = $this->servicesApiJobsGetJobsRequest($limit, $start, $order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LiltConnectorSDK\Model\JobsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\JobsResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\JobsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LiltConnectorSDK\Model\JobsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\JobsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation servicesApiJobsGetJobsAsync
     *
     * Retrieve a list of Connector Jobs.
     *
     * @param  int $limit the query limit (optional, default to 25)
     * @param  int $start where to start (optional, default to 0)
     * @param  string $order how to order the returned results (optional, default to 'asc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsGetJobs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesApiJobsGetJobsAsync($limit = 25, $start = 0, $order = 'asc', string $contentType = self::contentTypes['servicesApiJobsGetJobs'][0])
    {
        return $this->servicesApiJobsGetJobsAsyncWithHttpInfo($limit, $start, $order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation servicesApiJobsGetJobsAsyncWithHttpInfo
     *
     * Retrieve a list of Connector Jobs.
     *
     * @param  int $limit the query limit (optional, default to 25)
     * @param  int $start where to start (optional, default to 0)
     * @param  string $order how to order the returned results (optional, default to 'asc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsGetJobs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesApiJobsGetJobsAsyncWithHttpInfo($limit = 25, $start = 0, $order = 'asc', string $contentType = self::contentTypes['servicesApiJobsGetJobs'][0])
    {
        $returnType = '\LiltConnectorSDK\Model\JobsResponse';
        $request = $this->servicesApiJobsGetJobsRequest($limit, $start, $order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'servicesApiJobsGetJobs'
     *
     * @param  int $limit the query limit (optional, default to 25)
     * @param  int $start where to start (optional, default to 0)
     * @param  string $order how to order the returned results (optional, default to 'asc')
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsGetJobs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function servicesApiJobsGetJobsRequest($limit = 25, $start = 0, $order = 'asc', string $contentType = self::contentTypes['servicesApiJobsGetJobs'][0])
    {





        $resourcePath = '/jobs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order,
            'order', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation servicesApiJobsStartJob
     *
     * Start a Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsStartJob'] to see the possible values for this operation
     *
     * @throws \LiltConnectorSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function servicesApiJobsStartJob($id, string $contentType = self::contentTypes['servicesApiJobsStartJob'][0])
    {
        $this->servicesApiJobsStartJobWithHttpInfo($id, $contentType);
    }

    /**
     * Operation servicesApiJobsStartJobWithHttpInfo
     *
     * Start a Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsStartJob'] to see the possible values for this operation
     *
     * @throws \LiltConnectorSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function servicesApiJobsStartJobWithHttpInfo($id, string $contentType = self::contentTypes['servicesApiJobsStartJob'][0])
    {
        $request = $this->servicesApiJobsStartJobRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation servicesApiJobsStartJobAsync
     *
     * Start a Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsStartJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesApiJobsStartJobAsync($id, string $contentType = self::contentTypes['servicesApiJobsStartJob'][0])
    {
        return $this->servicesApiJobsStartJobAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation servicesApiJobsStartJobAsyncWithHttpInfo
     *
     * Start a Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsStartJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesApiJobsStartJobAsyncWithHttpInfo($id, string $contentType = self::contentTypes['servicesApiJobsStartJob'][0])
    {
        $returnType = '';
        $request = $this->servicesApiJobsStartJobRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'servicesApiJobsStartJob'
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsStartJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function servicesApiJobsStartJobRequest($id, string $contentType = self::contentTypes['servicesApiJobsStartJob'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling servicesApiJobsStartJob'
            );
        }


        $resourcePath = '/jobs/{id}/start';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation servicesApiJobsSyncJob
     *
     * Start a Sync.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsSyncJob'] to see the possible values for this operation
     *
     * @throws \LiltConnectorSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function servicesApiJobsSyncJob($id, string $contentType = self::contentTypes['servicesApiJobsSyncJob'][0])
    {
        $this->servicesApiJobsSyncJobWithHttpInfo($id, $contentType);
    }

    /**
     * Operation servicesApiJobsSyncJobWithHttpInfo
     *
     * Start a Sync.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsSyncJob'] to see the possible values for this operation
     *
     * @throws \LiltConnectorSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function servicesApiJobsSyncJobWithHttpInfo($id, string $contentType = self::contentTypes['servicesApiJobsSyncJob'][0])
    {
        $request = $this->servicesApiJobsSyncJobRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation servicesApiJobsSyncJobAsync
     *
     * Start a Sync.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsSyncJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesApiJobsSyncJobAsync($id, string $contentType = self::contentTypes['servicesApiJobsSyncJob'][0])
    {
        return $this->servicesApiJobsSyncJobAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation servicesApiJobsSyncJobAsyncWithHttpInfo
     *
     * Start a Sync.
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsSyncJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesApiJobsSyncJobAsyncWithHttpInfo($id, string $contentType = self::contentTypes['servicesApiJobsSyncJob'][0])
    {
        $returnType = '';
        $request = $this->servicesApiJobsSyncJobRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'servicesApiJobsSyncJob'
     *
     * @param  int $id The Job ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsSyncJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function servicesApiJobsSyncJobRequest($id, string $contentType = self::contentTypes['servicesApiJobsSyncJob'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling servicesApiJobsSyncJob'
            );
        }


        $resourcePath = '/jobs/{id}/sync';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation servicesApiJobsUpdateJob
     *
     * Update a Connector Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  \LiltConnectorSDK\Model\UpdateJobOptions $update_job_options update_job_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsUpdateJob'] to see the possible values for this operation
     *
     * @throws \LiltConnectorSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \LiltConnectorSDK\Model\JobResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse
     */
    public function servicesApiJobsUpdateJob($id, $update_job_options = null, string $contentType = self::contentTypes['servicesApiJobsUpdateJob'][0])
    {
        list($response) = $this->servicesApiJobsUpdateJobWithHttpInfo($id, $update_job_options, $contentType);
        return $response;
    }

    /**
     * Operation servicesApiJobsUpdateJobWithHttpInfo
     *
     * Update a Connector Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  \LiltConnectorSDK\Model\UpdateJobOptions $update_job_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsUpdateJob'] to see the possible values for this operation
     *
     * @throws \LiltConnectorSDK\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \LiltConnectorSDK\Model\JobResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse|\LiltConnectorSDK\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function servicesApiJobsUpdateJobWithHttpInfo($id, $update_job_options = null, string $contentType = self::contentTypes['servicesApiJobsUpdateJob'][0])
    {
        $request = $this->servicesApiJobsUpdateJobRequest($id, $update_job_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\LiltConnectorSDK\Model\JobResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\JobResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\JobResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\LiltConnectorSDK\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\LiltConnectorSDK\Model\ErrorResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\LiltConnectorSDK\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\LiltConnectorSDK\Model\JobResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\JobResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\LiltConnectorSDK\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation servicesApiJobsUpdateJobAsync
     *
     * Update a Connector Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  \LiltConnectorSDK\Model\UpdateJobOptions $update_job_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsUpdateJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesApiJobsUpdateJobAsync($id, $update_job_options = null, string $contentType = self::contentTypes['servicesApiJobsUpdateJob'][0])
    {
        return $this->servicesApiJobsUpdateJobAsyncWithHttpInfo($id, $update_job_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation servicesApiJobsUpdateJobAsyncWithHttpInfo
     *
     * Update a Connector Job.
     *
     * @param  int $id The Job ID. (required)
     * @param  \LiltConnectorSDK\Model\UpdateJobOptions $update_job_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsUpdateJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function servicesApiJobsUpdateJobAsyncWithHttpInfo($id, $update_job_options = null, string $contentType = self::contentTypes['servicesApiJobsUpdateJob'][0])
    {
        $returnType = '\LiltConnectorSDK\Model\JobResponse';
        $request = $this->servicesApiJobsUpdateJobRequest($id, $update_job_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'servicesApiJobsUpdateJob'
     *
     * @param  int $id The Job ID. (required)
     * @param  \LiltConnectorSDK\Model\UpdateJobOptions $update_job_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['servicesApiJobsUpdateJob'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function servicesApiJobsUpdateJobRequest($id, $update_job_options = null, string $contentType = self::contentTypes['servicesApiJobsUpdateJob'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling servicesApiJobsUpdateJob'
            );
        }



        $resourcePath = '/jobs/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_job_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_job_options));
            } else {
                $httpBody = $update_job_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
